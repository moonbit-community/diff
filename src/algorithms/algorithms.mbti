package "ruifeng/diff/algorithms"

// Values
fn[T : Eq] common_prefix_len(Array[T], Range, Array[T], Range) -> Int

fn[T : Eq] common_suffix_len(Array[T], Range, Array[T], Range) -> Int

fn[T : Eq + Hash] unique(Array[T], Range) -> Array[UniqueItem[T]]

// Types and methods
type Capture
fn Capture::into_ops(Self) -> Array[DiffOp]
fn Capture::new() -> Self
fn Capture::ops(Self) -> Array[DiffOp]
fn Capture::sort(Self) -> Unit
fn Capture::to_iter(Self) -> Iter[DiffOp]
impl Default for Capture
impl DiffHook for Capture

pub(all) enum DiffOp {
  Equal(old_index~ : Int, new_index~ : Int, len~ : Int)
  Delete(old_index~ : Int, old_len~ : Int, new_index~ : Int)
  Insert(old_index~ : Int, new_index~ : Int, new_len~ : Int)
  Replace(old_index~ : Int, old_len~ : Int, new_index~ : Int, new_len~ : Int)
  Finish
}
impl Compare for DiffOp
impl Eq for DiffOp
impl Hash for DiffOp
impl Show for DiffOp

type Myers
fn[T : Eq, D : DiffHook] Myers::diff(D, Array[T], Range, Array[T], Range) -> Result[Unit, Error]

pub(all) struct NoFinishHook[D] {
  d : D
}
fn[D] NoFinishHook::into_inner(Self[D]) -> D
fn[D] NoFinishHook::new(D) -> Self[D]

pub(all) struct Patience[T, D] {
  d : D
  old : Array[T]
  mut old_current : Int
  old_end : Int
  old_indexes : Array[UniqueItem[T]]
  new : Array[T]
  mut new_current : Int
  new_end : Int
  new_indexes : Array[UniqueItem[T]]
}
fn[T : Eq + Hash, D : DiffHook] Patience::diff(D, Array[T], Range, Array[T], Range) -> Result[Unit, Error]

pub(all) struct Range {
  mut start : Int
  mut end : Int
}
fn Range::contains(Self, Int) -> Bool
fn Range::is_empty(Self) -> Bool
fn Range::iter(Self) -> Iter[Int]
fn Range::len(Self) -> Int
fn Range::new(Int, Int) -> Self
impl Show for Range

pub(all) struct Replace[D] {
  d : D
  mut del : (Int, Int, Int)?
  mut ins : (Int, Int, Int)?
  mut eq : (Int, Int, Int)?
}
fn[D : DiffHook] Replace::flush_del_ins(Self[D]) -> Result[Unit, Error]
fn[D : DiffHook] Replace::flush_eq(Self[D]) -> Result[Unit, Error]
fn[D : DiffHook] Replace::into_inner(Self[D]) -> D
fn[D : DiffHook] Replace::new(D) -> Self[D]
impl[D : DiffHook] DiffHook for Replace[D]

type UniqueItem[T]

type V
fn V::len(Self) -> Int
fn V::new(Int) -> Self
fn V::op_get(Self, Int) -> Int
fn V::op_set(Self, Int, Int) -> Unit

// Type aliases

// Traits
pub(open) trait DiffHook {
  equal(Self, Int, Int, Int) -> Result[Unit, Error] = _
  delete(Self, Int, Int, Int) -> Result[Unit, Error] = _
  insert(Self, Int, Int, Int) -> Result[Unit, Error] = _
  replace(Self, Int, Int, Int, Int) -> Result[Unit, Error] = _
  finish(Self) -> Result[Unit, Error] = _
}

